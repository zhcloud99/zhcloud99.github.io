<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>zhcloud</title>
  
  <subtitle>zh的个人博客</subtitle>
  <link href="https://zhcloud99.github.io/atom.xml" rel="self"/>
  
  <link href="https://zhcloud99.github.io/"/>
  <updated>2021-04-24T08:44:50.623Z</updated>
  <id>https://zhcloud99.github.io/</id>
  
  <author>
    <name>zhcloud</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>LeetCode题解-435</title>
    <link href="https://zhcloud99.github.io/20210424044346.html"/>
    <id>https://zhcloud99.github.io/20210424044346.html</id>
    <published>2021-04-24T08:43:46.000Z</published>
    <updated>2021-04-24T08:44:50.623Z</updated>
    
    <content type="html"><![CDATA[<p><strong>题目描述</strong><br>&ensp;&ensp;&ensp;&ensp;给定一个区间的集合，找到需要移除区间的最小数量，使剩余区间互不重叠。</p><p><strong>解题思路</strong></p><ul><li>先将n行2列的二维数组按照第二列的数字从小到大进行排列</li><li>以排序后的二维数组的第一个数组的右边界（第一列的数）为起始比较点，对排序后的二维数组从第二行开始进行比较</li><li>如果当前一维数组的左边边界比当前的起始比较点小，此数组为要删除的数组,删除的个数加一</li><li>如果当前一维数组的左边边界比当前的起始比较点大，将此数组更新为新的起始比较点</li></ul><p><strong>图解</strong><br><img src="/20210424044346/435.png"></p><p><strong>代码</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">eraseOverlapIntervals</span><span class="params">(<span class="keyword">int</span>[][] intervals)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(intervals.length == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Arrays.sort(intervals, <span class="keyword">new</span> Comparator&lt;<span class="keyword">int</span>[]&gt;()&#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(<span class="keyword">int</span>[] o1, <span class="keyword">int</span>[] o2)</span></span>&#123;</span><br><span class="line">                <span class="keyword">return</span> o1[<span class="number">1</span>] - o2[<span class="number">1</span>]; <span class="comment">//二维数组按照第二列排序</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> start = intervals[<span class="number">0</span>][<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt; intervals.length;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(intervals[i][<span class="number">0</span>] &lt; start)&#123;</span><br><span class="line">                res++;   </span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                start = intervals[i][<span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;strong&gt;题目描述&lt;/strong&gt;&lt;br&gt;&amp;ensp;&amp;ensp;&amp;ensp;&amp;ensp;给定一个区间的集合，找到需要移除区间的最小数量，使剩余区间互不重叠。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;解题思路&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;先将n行2列的二维数组</summary>
      
    
    
    
    <category term="LeetCode题解" scheme="https://zhcloud99.github.io/categories/LeetCode%E9%A2%98%E8%A7%A3/"/>
    
    <category term="贪心" scheme="https://zhcloud99.github.io/categories/LeetCode%E9%A2%98%E8%A7%A3/%E8%B4%AA%E5%BF%83/"/>
    
    
    <category term="算法题解" scheme="https://zhcloud99.github.io/tags/%E7%AE%97%E6%B3%95%E9%A2%98%E8%A7%A3/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode题解-215</title>
    <link href="https://zhcloud99.github.io/20210423034046.html"/>
    <id>https://zhcloud99.github.io/20210423034046.html</id>
    <published>2021-04-23T07:40:46.000Z</published>
    <updated>2021-04-23T07:41:28.264Z</updated>
    
    <content type="html"><![CDATA[<p><strong>题目描述</strong><br>&ensp;&ensp;&ensp;&ensp;在未排序的数组中找到第k个最大的元素。请注意，你需要找的是数组排序后的第k个最大的元素，而不是第k个不同的元素。</p><p><strong>解题思路</strong>：</p><ul><li>不断维护一个大顶堆，第k次时，就是第k大的元素，麻烦~~~~~~</li><li>直接对数组升序排列，第k大的元素下标是nums.length-k</li><li>对数组循环存入优先队列，队列里只能有k个元素，存取完毕后，队首即是第k大的元素</li></ul><p><strong>代码</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findKthLargest</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line">        <span class="keyword">return</span> nums[nums.length-k];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;strong&gt;题目描述&lt;/strong&gt;&lt;br&gt;&amp;ensp;&amp;ensp;&amp;ensp;&amp;ensp;在未排序的数组中找到第k个最大的元素。请注意，你需要找的是数组排序后的第k个最大的元素，而不是第k个不同的元素。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;解题思路&lt;/strong&gt;：&lt;/</summary>
      
    
    
    
    <category term="LeetCode题解" scheme="https://zhcloud99.github.io/categories/LeetCode%E9%A2%98%E8%A7%A3/"/>
    
    <category term="排序" scheme="https://zhcloud99.github.io/categories/LeetCode%E9%A2%98%E8%A7%A3/%E6%8E%92%E5%BA%8F/"/>
    
    
    <category term="算法题解" scheme="https://zhcloud99.github.io/tags/%E7%AE%97%E6%B3%95%E9%A2%98%E8%A7%A3/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode题解-347</title>
    <link href="https://zhcloud99.github.io/20210423033846.html"/>
    <id>https://zhcloud99.github.io/20210423033846.html</id>
    <published>2021-04-23T07:38:46.000Z</published>
    <updated>2021-04-23T07:41:41.957Z</updated>
    
    <content type="html"><![CDATA[<p><strong>题目描述</strong><br>&ensp;&ensp;&ensp;&ensp;给你一个整数数组nums和一个整数k，请你返回其中出现频率前k高的元素。你可以按任意顺序返回答案。</p><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a><strong>解题思路</strong></h2><h3 id="桶排序法"><a href="#桶排序法" class="headerlink" title="桶排序法"></a>桶排序法</h3><ul><li>使用HashMap统计每个数字出现的频率，key为数字，value为数字对应的频率</li><li>将HashMap中的key部分存放到数组中，key对应的数组下标为key的频率（例如5出现了3次，key=5，value=3；将5放入数组中，对应的下标为3，即出现3次的是5 ）,为防止出现有频率同的数字，应该是List类型的数组。</li></ul><p><strong>代码</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] topKFrequent(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k) &#123;</span><br><span class="line">        Map&lt;Integer,Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;(); </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> num : nums)&#123;</span><br><span class="line">            <span class="keyword">if</span>(map.containsKey(num))&#123;</span><br><span class="line">                map.put(num,map.get(num)+<span class="number">1</span>);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                map.put(num,<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        List[] res = <span class="keyword">new</span> List[nums.length+<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> key:map.keySet())&#123;</span><br><span class="line">            <span class="keyword">int</span> value = map.get(key);</span><br><span class="line">            <span class="keyword">if</span>(res[value] == <span class="keyword">null</span>)&#123;</span><br><span class="line">                res[value] = <span class="keyword">new</span> ArrayList();</span><br><span class="line">            &#125;</span><br><span class="line">            res[value].add(key);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span>[] finalRes = <span class="keyword">new</span> <span class="keyword">int</span>[k];</span><br><span class="line">        <span class="keyword">int</span> times = <span class="number">0</span>;   <span class="comment">//times记录数组中已经存放元素个数与本次存放对应的下标位置</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = res.length-<span class="number">1</span>; i &gt;= <span class="number">0</span> &amp;&amp;  times &lt; k;i--)&#123;  </span><br><span class="line">            <span class="keyword">if</span> (res[i] == <span class="keyword">null</span>) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">for</span>(Object a:res[i])&#123;</span><br><span class="line">                finalRes[times] = (<span class="keyword">int</span>)a;</span><br><span class="line">                times++;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> finalRes;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;strong&gt;题目描述&lt;/strong&gt;&lt;br&gt;&amp;ensp;&amp;ensp;&amp;ensp;&amp;ensp;给你一个整数数组nums和一个整数k，请你返回其中出现频率前k高的元素。你可以按任意顺序返回答案。&lt;/p&gt;
&lt;h2 id=&quot;解题思路&quot;&gt;&lt;a href=&quot;#解题思路&quot; clas</summary>
      
    
    
    
    <category term="LeetCode题解" scheme="https://zhcloud99.github.io/categories/LeetCode%E9%A2%98%E8%A7%A3/"/>
    
    <category term="排序" scheme="https://zhcloud99.github.io/categories/LeetCode%E9%A2%98%E8%A7%A3/%E6%8E%92%E5%BA%8F/"/>
    
    
    <category term="算法题解" scheme="https://zhcloud99.github.io/tags/%E7%AE%97%E6%B3%95%E9%A2%98%E8%A7%A3/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode题解-451</title>
    <link href="https://zhcloud99.github.io/20210423033646.html"/>
    <id>https://zhcloud99.github.io/20210423033646.html</id>
    <published>2021-04-23T07:36:46.000Z</published>
    <updated>2021-04-23T07:41:35.015Z</updated>
    
    <content type="html"><![CDATA[<p><strong>题目描述</strong><br>&ensp;&ensp;&ensp;&ensp;给定一个字符串，请将字符串里的字符按照出现的频率降序排列。</p><p><strong>解题思路</strong><br><strong>同347题</strong></p><p><strong>代码</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">frequencySort</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (s == <span class="keyword">null</span> || s.length() == <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> s;</span><br><span class="line">        &#125;</span><br><span class="line">        Map&lt;Character,Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.length();i++ )&#123;</span><br><span class="line">            <span class="keyword">char</span> data = s.charAt(i);</span><br><span class="line">            <span class="keyword">if</span> (!map.containsKey(data))&#123;</span><br><span class="line">                map.put(data,<span class="number">1</span>);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                map.put(data,map.get(data)+<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        List&lt;Character&gt;[] list = <span class="keyword">new</span> List[s.length()+<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">char</span> key:map.keySet())&#123;</span><br><span class="line">            <span class="keyword">int</span> idx = map.get(key);</span><br><span class="line">            <span class="keyword">if</span>(list[idx] == <span class="keyword">null</span> )&#123;</span><br><span class="line">                list[idx] = <span class="keyword">new</span> ArrayList&lt;Character&gt;();</span><br><span class="line">            &#125;</span><br><span class="line">            list[idx].add(key);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        StringBuffer res = <span class="keyword">new</span> StringBuffer();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = list.length-<span class="number">1</span>;i &gt; <span class="number">0</span>;i--)&#123;</span><br><span class="line">            <span class="keyword">if</span>(list[i] != <span class="keyword">null</span>)&#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">char</span> a:list[i])&#123;</span><br><span class="line">                    <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>;j &lt; i;j++)&#123;</span><br><span class="line">                        res.append(a);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;strong&gt;题目描述&lt;/strong&gt;&lt;br&gt;&amp;ensp;&amp;ensp;&amp;ensp;&amp;ensp;给定一个字符串，请将字符串里的字符按照出现的频率降序排列。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;解题思路&lt;/strong&gt;&lt;br&gt;&lt;strong&gt;同347题&lt;/strong&gt;&lt;/p&gt;</summary>
      
    
    
    
    <category term="LeetCode题解" scheme="https://zhcloud99.github.io/categories/LeetCode%E9%A2%98%E8%A7%A3/"/>
    
    <category term="排序" scheme="https://zhcloud99.github.io/categories/LeetCode%E9%A2%98%E8%A7%A3/%E6%8E%92%E5%BA%8F/"/>
    
    
    <category term="算法题解" scheme="https://zhcloud99.github.io/tags/%E7%AE%97%E6%B3%95%E9%A2%98%E8%A7%A3/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode题解-75</title>
    <link href="https://zhcloud99.github.io/20210423033346.html"/>
    <id>https://zhcloud99.github.io/20210423033346.html</id>
    <published>2021-04-23T07:33:46.000Z</published>
    <updated>2021-04-23T07:41:44.839Z</updated>
    
    <content type="html"><![CDATA[<p><strong>题目描述</strong><br>&ensp;&ensp;&ensp;&ensp;给定一个包含红色、白色和蓝色，一共n个元素的数组，原地对它们进行排序，使得相同颜色的元素相邻，并按照红色、白色、蓝色顺序排列。使用整数0、1和2分别表示红色、白色和蓝色。</p><p><strong>解题思路</strong> </p><ul><li>设置初始指针idx指向最左边，对数组从左往右遍历，碰到0就与指针对应的数字交换位置，然后指针右移一位</li><li>设置初始指针idx2指向最右边，对数组从右往左遍历，碰到2就与指针对应的数字交换位置，然后指针左移一位</li><li>两轮循环后0移动到最左边，2移动到最右边，1被放到最中间</li></ul><p><strong>或者</strong></p><ul><li>设置初始指针idx指向最左边，对数组从左往右遍历，碰到0就与指针对应的数字交换位置，然后指针右移一位</li><li>第一轮循环结束后，0全被放到最左边，以此时idx的下标开始往下循环，碰到数字1就与idx下标对应的数字交换位置，然后指针idx右移一位</li><li>两轮循环后0移动到最左边，1移动到0的后面，2被放到最后</li></ul><p><strong>代码：第一种思路</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sortColors</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> idx = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i&lt;nums.length;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i] == <span class="number">0</span>)&#123;</span><br><span class="line">                nums[i] = nums[idx];</span><br><span class="line">                nums[idx++] = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> idx2 = nums.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = idx2;j &gt;=<span class="number">0</span>;j--)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[j] == <span class="number">2</span>)&#123;</span><br><span class="line">                nums[j] = nums[idx2];</span><br><span class="line">                nums[idx2--] = <span class="number">2</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;strong&gt;题目描述&lt;/strong&gt;&lt;br&gt;&amp;ensp;&amp;ensp;&amp;ensp;&amp;ensp;给定一个包含红色、白色和蓝色，一共n个元素的数组，原地对它们进行排序，使得相同颜色的元素相邻，并按照红色、白色、蓝色顺序排列。使用整数0、1和2分别表示红色、白色和蓝色。&lt;/p</summary>
      
    
    
    
    <category term="LeetCode题解" scheme="https://zhcloud99.github.io/categories/LeetCode%E9%A2%98%E8%A7%A3/"/>
    
    <category term="排序" scheme="https://zhcloud99.github.io/categories/LeetCode%E9%A2%98%E8%A7%A3/%E6%8E%92%E5%BA%8F/"/>
    
    
    <category term="算法题解" scheme="https://zhcloud99.github.io/tags/%E7%AE%97%E6%B3%95%E9%A2%98%E8%A7%A3/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode题解-141</title>
    <link href="https://zhcloud99.github.io/20210421041446.html"/>
    <id>https://zhcloud99.github.io/20210421041446.html</id>
    <published>2021-04-21T08:14:46.000Z</published>
    <updated>2021-04-21T08:15:38.501Z</updated>
    
    <content type="html"><![CDATA[<p><strong>题目描述</strong><br>&ensp;&ensp;&ensp;&ensp;给定一个链表，判断链表中是否有环。</p><p><strong>解题思路</strong><br>&ensp;&ensp;&ensp;&ensp;使用双指针，一个指针每次移动一个节点，一个指针每次移动两个节点，如果存在环，那么这两个指针一定会相遇。</p><p><strong>代码</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasCycle</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        ListNode one = head;</span><br><span class="line">        ListNode two = head.next;</span><br><span class="line">        <span class="keyword">while</span>(one != <span class="keyword">null</span> &amp;&amp; two != <span class="keyword">null</span> &amp;&amp; two.next != <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span> (one == two)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            one = one.next;</span><br><span class="line">            two = two.next.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;strong&gt;题目描述&lt;/strong&gt;&lt;br&gt;&amp;ensp;&amp;ensp;&amp;ensp;&amp;ensp;给定一个链表，判断链表中是否有环。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;解题思路&lt;/strong&gt;&lt;br&gt;&amp;ensp;&amp;ensp;&amp;ensp;&amp;ensp;使用双指针，一个指针每次移动</summary>
      
    
    
    
    <category term="LeetCode题解" scheme="https://zhcloud99.github.io/categories/LeetCode%E9%A2%98%E8%A7%A3/"/>
    
    <category term="双指针" scheme="https://zhcloud99.github.io/categories/LeetCode%E9%A2%98%E8%A7%A3/%E5%8F%8C%E6%8C%87%E9%92%88/"/>
    
    
    <category term="算法题解" scheme="https://zhcloud99.github.io/tags/%E7%AE%97%E6%B3%95%E9%A2%98%E8%A7%A3/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode题解-88</title>
    <link href="https://zhcloud99.github.io/20210421041246.html"/>
    <id>https://zhcloud99.github.io/20210421041246.html</id>
    <published>2021-04-21T08:12:46.000Z</published>
    <updated>2021-04-21T08:15:52.325Z</updated>
    
    <content type="html"><![CDATA[<p><strong>题目描述</strong><br>&ensp;&ensp;&ensp;&ensp;给你两个有序整数数组nums1和nums2，请你将nums2合并到nums1中，使nums1成为一个有序数组。</p><p><strong>解题思路</strong><br>&ensp;&ensp;&ensp;&ensp;先创建一个容量为两个数组容量之和的数组arr，然后在nums1与nums2起始下标放指针，将两个数组中的数按照大小依次放进数组arr。<br>&ensp;&ensp;&ensp;&ensp;为防止nums1与nums2其中一个放完另一个没放完，还要对此情况进行判断。</p><p><strong>代码</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span>[] nums1, <span class="keyword">int</span> m, <span class="keyword">int</span>[] nums2, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> total = m + n;</span><br><span class="line">        <span class="keyword">int</span>[] arr = <span class="keyword">new</span> <span class="keyword">int</span>[total];</span><br><span class="line">        <span class="keyword">int</span> idx = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span> ,j = <span class="number">0</span>; i &lt; m || j &lt; n; )&#123;</span><br><span class="line">            <span class="keyword">if</span> (i &lt; m &amp;&amp; j &lt; n)&#123;</span><br><span class="line">                arr[idx++] = nums1[i] &lt; nums2[j] ? nums1[i++]:nums2[j++];</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span> (i &lt; m )&#123;</span><br><span class="line">                arr[idx++] = nums1[i++];</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span> (j &lt; n)&#123;</span><br><span class="line">                arr[idx++] = nums2[j++];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.arraycopy(arr, <span class="number">0</span>, nums1, <span class="number">0</span>, total);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;strong&gt;题目描述&lt;/strong&gt;&lt;br&gt;&amp;ensp;&amp;ensp;&amp;ensp;&amp;ensp;给你两个有序整数数组nums1和nums2，请你将nums2合并到nums1中，使nums1成为一个有序数组。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;解题思路&lt;/strong&gt;&lt;br&gt;</summary>
      
    
    
    
    <category term="LeetCode题解" scheme="https://zhcloud99.github.io/categories/LeetCode%E9%A2%98%E8%A7%A3/"/>
    
    <category term="双指针" scheme="https://zhcloud99.github.io/categories/LeetCode%E9%A2%98%E8%A7%A3/%E5%8F%8C%E6%8C%87%E9%92%88/"/>
    
    
    <category term="算法题解" scheme="https://zhcloud99.github.io/tags/%E7%AE%97%E6%B3%95%E9%A2%98%E8%A7%A3/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode题解-680</title>
    <link href="https://zhcloud99.github.io/20210421041046.html"/>
    <id>https://zhcloud99.github.io/20210421041046.html</id>
    <published>2021-04-21T08:10:46.000Z</published>
    <updated>2021-04-21T08:15:44.582Z</updated>
    
    <content type="html"><![CDATA[<p><strong>题目描述</strong><br>&ensp;&ensp;&ensp;&ensp;给定一个非空字符串s，最多删除一个字符。判断是否能成为回文字符串。</p><p><strong>解题思路</strong></p><ul><li>两边指针同时判断，碰到不相等的时候先尝试跳过左边的，左边的下标+1，的接着往下比较，若下面还有不相等的直接返回false</li><li>然后尝试跳过右边的，右边的下标-1，的接着往下比较，若下面还有不相等的直接返回false</li><li>以上只要有一个情况满足是回文字符串，即是回文字符串</li></ul><p><strong>代码</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">validPalindrome</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>,j = s.length()-<span class="number">1</span>;i &lt; j; i++,j--)&#123;</span><br><span class="line">            <span class="keyword">if</span> (s.charAt(i) != s.charAt(j))&#123;</span><br><span class="line">                <span class="keyword">return</span> isPal(s,i,j-<span class="number">1</span>) || isPal(s,i+<span class="number">1</span>,j);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isPal</span><span class="params">(String s ,<span class="keyword">int</span> i,<span class="keyword">int</span> j)</span></span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (i &lt; j)&#123;</span><br><span class="line">            <span class="keyword">if</span>(s.charAt(i) != s.charAt(j))&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">                i++;</span><br><span class="line">                j--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;strong&gt;题目描述&lt;/strong&gt;&lt;br&gt;&amp;ensp;&amp;ensp;&amp;ensp;&amp;ensp;给定一个非空字符串s，最多删除一个字符。判断是否能成为回文字符串。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;解题思路&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;两边指针同时判断，碰到不</summary>
      
    
    
    
    <category term="LeetCode题解" scheme="https://zhcloud99.github.io/categories/LeetCode%E9%A2%98%E8%A7%A3/"/>
    
    <category term="双指针" scheme="https://zhcloud99.github.io/categories/LeetCode%E9%A2%98%E8%A7%A3/%E5%8F%8C%E6%8C%87%E9%92%88/"/>
    
    
    <category term="算法题解" scheme="https://zhcloud99.github.io/tags/%E7%AE%97%E6%B3%95%E9%A2%98%E8%A7%A3/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode题解-345</title>
    <link href="https://zhcloud99.github.io/20210421040746.html"/>
    <id>https://zhcloud99.github.io/20210421040746.html</id>
    <published>2021-04-21T08:07:46.000Z</published>
    <updated>2021-04-21T08:15:41.477Z</updated>
    
    <content type="html"><![CDATA[<p><strong>题目描述</strong><br>&ensp;&ensp;&ensp;&ensp;编写一个函数，以字符串作为输入，反转该字符串中的元音字母。</p><p><strong>解题思路</strong></p><ul><li>将所有元音字母放入集合中，以方便进行判断</li><li>设置两个指针，left从左向右移动，right从右向左移动</li><li>两个指针没有碰到元音字母时，继续移动；碰到元音字母时，停止在元音字母的位置</li><li>当两个指针都在元音字母的位置时候，交换两个元音字母的位置</li></ul><p><strong>代码</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> HashSet&lt;Character&gt; hs = <span class="keyword">new</span> HashSet&lt;&gt;(Arrays.asList(<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;e&#x27;</span>,<span class="string">&#x27;i&#x27;</span>,<span class="string">&#x27;o&#x27;</span>,<span class="string">&#x27;u&#x27;</span>,<span class="string">&#x27;A&#x27;</span>,<span class="string">&#x27;E&#x27;</span>,<span class="string">&#x27;I&#x27;</span>,<span class="string">&#x27;O&#x27;</span>,<span class="string">&#x27;U&#x27;</span>));</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">reverseVowels</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (s == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">char</span>[] res = <span class="keyword">new</span> <span class="keyword">char</span>[s.length()];</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> right = s.length()-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (left &lt;= right)&#123;</span><br><span class="line">            <span class="keyword">char</span> cl = s.charAt(left);</span><br><span class="line">            <span class="keyword">char</span> cr = s.charAt(right);</span><br><span class="line">            <span class="keyword">if</span>(!hs.contains(cl))&#123;</span><br><span class="line">                res[left] = cl;</span><br><span class="line">                left++; </span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(!hs.contains(cr))&#123;</span><br><span class="line">                res[right] = cr;</span><br><span class="line">                right--;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(hs.contains(cl) &amp;&amp; hs.contains(cr))&#123;</span><br><span class="line">                res[left++] = cr;</span><br><span class="line">                res[right--] = cl;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> String(res);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;strong&gt;题目描述&lt;/strong&gt;&lt;br&gt;&amp;ensp;&amp;ensp;&amp;ensp;&amp;ensp;编写一个函数，以字符串作为输入，反转该字符串中的元音字母。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;解题思路&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;将所有元音字母放入集合中，以方便</summary>
      
    
    
    
    <category term="LeetCode题解" scheme="https://zhcloud99.github.io/categories/LeetCode%E9%A2%98%E8%A7%A3/"/>
    
    <category term="双指针" scheme="https://zhcloud99.github.io/categories/LeetCode%E9%A2%98%E8%A7%A3/%E5%8F%8C%E6%8C%87%E9%92%88/"/>
    
    
    <category term="算法题解" scheme="https://zhcloud99.github.io/tags/%E7%AE%97%E6%B3%95%E9%A2%98%E8%A7%A3/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode题解-633</title>
    <link href="https://zhcloud99.github.io/20210421040146.html"/>
    <id>https://zhcloud99.github.io/20210421040146.html</id>
    <published>2021-04-21T08:01:46.000Z</published>
    <updated>2021-04-21T08:01:29.920Z</updated>
    
    <content type="html"><![CDATA[<p><strong>题目描述</strong><br>&ensp;&ensp;&ensp;&ensp;给定一个非负整数c，你要判断是否存在两个整数a和b，使得 a^2 + b^2 = c。</p><p><strong>解题思路</strong><br>&ensp;&ensp;&ensp;&ensp;给定的数字为n，则尝试i从0开始，j从根号n开始，看i与j平方相加是否等于给定的数字n。</p><ul><li>如果结果比n大，则j减一，使得后面的结果小一点</li><li>如果结果比n小，则i加一，使得后面的结果大一点</li></ul><p><strong>代码</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">judgeSquareSum</span><span class="params">(<span class="keyword">int</span> c)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (c &lt; <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> j = (<span class="keyword">int</span>)Math.sqrt(c);</span><br><span class="line">        <span class="keyword">while</span> (i &lt;= j)&#123;</span><br><span class="line">            <span class="keyword">int</span> res = i*i + j*j;</span><br><span class="line">            <span class="keyword">if</span> (res == c)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(res &gt; c)&#123;</span><br><span class="line">                j--;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;strong&gt;题目描述&lt;/strong&gt;&lt;br&gt;&amp;ensp;&amp;ensp;&amp;ensp;&amp;ensp;给定一个非负整数c，你要判断是否存在两个整数a和b，使得 a^2 + b^2 = c。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;解题思路&lt;/strong&gt;&lt;br&gt;&amp;ensp;&amp;ensp;</summary>
      
    
    
    
    <category term="LeetCode题解" scheme="https://zhcloud99.github.io/categories/LeetCode%E9%A2%98%E8%A7%A3/"/>
    
    <category term="双指针" scheme="https://zhcloud99.github.io/categories/LeetCode%E9%A2%98%E8%A7%A3/%E5%8F%8C%E6%8C%87%E9%92%88/"/>
    
    
    <category term="算法题解" scheme="https://zhcloud99.github.io/tags/%E7%AE%97%E6%B3%95%E9%A2%98%E8%A7%A3/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode题解-167</title>
    <link href="https://zhcloud99.github.io/20210421035146.html"/>
    <id>https://zhcloud99.github.io/20210421035146.html</id>
    <published>2021-04-21T07:51:46.000Z</published>
    <updated>2021-04-21T07:59:27.414Z</updated>
    
    <content type="html"><![CDATA[<p><strong>题目描述</strong><br>&ensp;&ensp;&ensp;&ensp;给定一个已按照升序排列的整数数组numbers，请你从数组中找出两个数满足相加之和等于目标数target。</p><p><strong>解题思路</strong><br>&ensp;&ensp;&ensp;&ensp;使用双指针left与right，left指向值较小的元素，right指向值较大的元素。left从左向右移动，right从右向左移动。</p><ul><li>如果两个指针指向元素的和 sum == target，那么得到要求的结果</li><li>如果 sum &gt; target，right向左移动，使 sum 变小一些</li><li>如果 sum &lt; target，left向右移动，使 sum 变大一些</li></ul><p><strong>代码</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] twoSum(<span class="keyword">int</span>[] numbers, <span class="keyword">int</span> target) &#123;</span><br><span class="line">        <span class="keyword">if</span> (numbers == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> right = numbers.length-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span>[] res = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">2</span>]; </span><br><span class="line">        <span class="keyword">while</span>(left &lt; right)&#123;</span><br><span class="line">            <span class="keyword">int</span> sum = numbers[left] + numbers[right];</span><br><span class="line">            <span class="keyword">if</span>(sum == target)&#123;</span><br><span class="line">                res[<span class="number">0</span>] = left+<span class="number">1</span>;</span><br><span class="line">                res[<span class="number">1</span>] = right+<span class="number">1</span>;</span><br><span class="line">                <span class="keyword">return</span> res;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(sum &gt; target)&#123;</span><br><span class="line">                right --;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                left ++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;strong&gt;题目描述&lt;/strong&gt;&lt;br&gt;&amp;ensp;&amp;ensp;&amp;ensp;&amp;ensp;给定一个已按照升序排列的整数数组numbers，请你从数组中找出两个数满足相加之和等于目标数target。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;解题思路&lt;/strong&gt;&lt;br&gt;&amp;e</summary>
      
    
    
    
    <category term="LeetCode题解" scheme="https://zhcloud99.github.io/categories/LeetCode%E9%A2%98%E8%A7%A3/"/>
    
    <category term="双指针" scheme="https://zhcloud99.github.io/categories/LeetCode%E9%A2%98%E8%A7%A3/%E5%8F%8C%E6%8C%87%E9%92%88/"/>
    
    
    <category term="算法题解" scheme="https://zhcloud99.github.io/tags/%E7%AE%97%E6%B3%95%E9%A2%98%E8%A7%A3/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode题解-524</title>
    <link href="https://zhcloud99.github.io/20210421033746.html"/>
    <id>https://zhcloud99.github.io/20210421033746.html</id>
    <published>2021-04-21T07:37:46.000Z</published>
    <updated>2021-04-21T08:15:32.934Z</updated>
    
    <content type="html"><![CDATA[<p><strong>题目描述</strong><br>&ensp;&ensp;&ensp;&ensp;给定一个字符串和一个字符串字典，找到字典里面最长的字符串，该字符串可以通过删除给定字符串的某些字符来得到。如果答案不止一个，返回长度最长且字典顺序最小的字符串。如果答案不存在，则返回空字符串。</p><p><strong>解题思路</strong><br>&ensp;&ensp;&ensp;&ensp;对List集合中的字符串挨个进行遍历，遍历时设置两个指针i与j，将i指针不断后移，看是否与j指针当前字符相等，相等的话则将j指针后移继续比较下一个。若j指针移到当前遍历的字符串最后面，说明当前字符串是给定字符串的一部分。<br>&ensp;&ensp;&ensp;&ensp;创建res字符串存储最后的结果，res每次更新都要满足以下条件：</p><ul><li>当前遍历的字符串为给定字符串的一部分</li><li>当前遍历的字符串长度比之前先得到的结果长度大</li><li>当前遍历的字符串长度与之前先得到的结果相等，但是字典顺序小</li></ul><p><strong>代码</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">findLongestWord</span><span class="params">(String s, List&lt;String&gt; dictionary)</span> </span>&#123;</span><br><span class="line">        String res = <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="keyword">for</span> (String target:dictionary)&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>,j=<span class="number">0</span>;i &lt; s.length() &amp;&amp; j &lt; target.length();i++)&#123;</span><br><span class="line">                <span class="keyword">if</span> (s.charAt(i) == target.charAt(j) )  j++;</span><br><span class="line">                <span class="keyword">if</span>(j == target.length())&#123;</span><br><span class="line">                    <span class="keyword">if</span>(target.length() &gt; res.length() || (target.length() == res.length() &amp;&amp; target.compareTo(res) &lt; <span class="number">0</span> ))&#123;</span><br><span class="line">                        res = target;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;strong&gt;题目描述&lt;/strong&gt;&lt;br&gt;&amp;ensp;&amp;ensp;&amp;ensp;&amp;ensp;给定一个字符串和一个字符串字典，找到字典里面最长的字符串，该字符串可以通过删除给定字符串的某些字符来得到。如果答案不止一个，返回长度最长且字典顺序最小的字符串。如果答案不存在，</summary>
      
    
    
    
    <category term="LeetCode题解" scheme="https://zhcloud99.github.io/categories/LeetCode%E9%A2%98%E8%A7%A3/"/>
    
    <category term="双指针" scheme="https://zhcloud99.github.io/categories/LeetCode%E9%A2%98%E8%A7%A3/%E5%8F%8C%E6%8C%87%E9%92%88/"/>
    
    
    <category term="算法题解" scheme="https://zhcloud99.github.io/tags/%E7%AE%97%E6%B3%95%E9%A2%98%E8%A7%A3/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode题解声明</title>
    <link href="https://zhcloud99.github.io/20210419041246.html"/>
    <id>https://zhcloud99.github.io/20210419041246.html</id>
    <published>2021-04-19T08:12:46.000Z</published>
    <updated>2021-04-24T09:13:39.088Z</updated>
    
    <content type="html"><![CDATA[<p><strong>声明</strong><br>&ensp;&ensp;&ensp;&ensp;本博客更新的LeetCode题解分类以及精选的题目均参考CyC2018博主的整理，代码与题解思路部分均为自行整理。</p><p>&ensp;&ensp;&ensp;&ensp;<strong>点击访问CyC2018博主的</strong><a href="https://github.com/CyC2018"><strong>github</strong></a></p><p>&ensp;&ensp;&ensp;&ensp;<strong>或者点此处</strong><a href="http://www.cyc2018.xyz/"><strong>访问</strong></a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;strong&gt;声明&lt;/strong&gt;&lt;br&gt;&amp;ensp;&amp;ensp;&amp;ensp;&amp;ensp;本博客更新的LeetCode题解分类以及精选的题目均参考CyC2018博主的整理，代码与题解思路部分均为自行整理。&lt;/p&gt;
&lt;p&gt;&amp;ensp;&amp;ensp;&amp;ensp;&amp;ensp;&lt;</summary>
      
    
    
    
    <category term="LeetCode题解" scheme="https://zhcloud99.github.io/categories/LeetCode%E9%A2%98%E8%A7%A3/"/>
    
    <category term="---&gt;这是个声明&lt;---" scheme="https://zhcloud99.github.io/categories/LeetCode%E9%A2%98%E8%A7%A3/%E8%BF%99%E6%98%AF%E4%B8%AA%E5%A3%B0%E6%98%8E/"/>
    
    
    <category term="算法题解" scheme="https://zhcloud99.github.io/tags/%E7%AE%97%E6%B3%95%E9%A2%98%E8%A7%A3/"/>
    
  </entry>
  
  <entry>
    <title>Web服务器、Web应用服务器、Web容器的区别、Servlet的定义、Servlet与JDBC的区别</title>
    <link href="https://zhcloud99.github.io/20210418093205.html"/>
    <id>https://zhcloud99.github.io/20210418093205.html</id>
    <published>2021-04-18T01:32:05.000Z</published>
    <updated>2021-04-18T01:35:20.281Z</updated>
    
    <content type="html"><![CDATA[<p><strong>Web服务器：</strong><br>&ensp;&ensp;&ensp;&ensp;最初的Web服务器只是负责处理HTTP协议，只能发送静态页面的内容，即处理浏览器等Web客户端的请求并返回相应响应。<br>&ensp;&ensp;&ensp;&ensp;Web服务器主要包括Nginx、Apache、IIS等。</p><p><strong>Web应用服务器</strong><br>&ensp;&ensp;&ensp;&ensp;后来人们不再满足于只从互联网获取静态的资源，便出现了通过Web服务器动态获取资源的技术，例如：JSP，ASP，PHP。而JSP，ASP，PHP等动态内容需要通过Web服务器的接口交给其它程序去处理，这个程序就是Web应用服务器。<br>&ensp;&ensp;&ensp;&ensp;Web应用服务器包括TomCat、WebLogic、JBoss等。<br>&ensp;&ensp;&ensp;&ensp;Web应用服务器一般也会部分支持HTTP协议，所以Web服务器与Web应用服务器的界限并没有那么清楚，但是Web应用服务器一般都是与Web服务器配合使用的。</p><p><strong>Web容器与Servlet</strong><br>&ensp;&ensp;&ensp;&ensp;一个Web应用可以在不同的Web应用服务器中被管理、运行，所以使用java开发Web应用、生成动态Web内容，以及开发的Web应用服务器能够处理Java开发的Web应用，都必须遵守一个规范，这个规范就是Servlet。<br>&ensp;&ensp;&ensp;&ensp;Web应用服务器也可以说是一个Servlet容器。</p><p><strong>Servlet与JDBC的区别</strong><br>&ensp;&ensp;&ensp;&ensp;狭义上来说，其实Servlet与JDBC都是一套纯粹的接口。<br>&ensp;&ensp;&ensp;&ensp;对于JDBC来说，各大数据库厂商实现了JDBC接口，程序员可以使用统一的java语言连接数据库，程序员永远是调用者；对于Servlet，程序员需要根据需求去实现Servlet接口，然后客户发出相应的Servlet请求时，Web应用服务器来调用实现的Servlet功能。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;strong&gt;Web服务器：&lt;/strong&gt;&lt;br&gt;&amp;ensp;&amp;ensp;&amp;ensp;&amp;ensp;最初的Web服务器只是负责处理HTTP协议，只能发送静态页面的内容，即处理浏览器等Web客户端的请求并返回相应响应。&lt;br&gt;&amp;ensp;&amp;ensp;&amp;ensp;&amp;ensp</summary>
      
    
    
    
    <category term="随想" scheme="https://zhcloud99.github.io/categories/%E9%9A%8F%E6%83%B3/"/>
    
    
    <category term="胡思乱想" scheme="https://zhcloud99.github.io/tags/%E8%83%A1%E6%80%9D%E4%B9%B1%E6%83%B3/"/>
    
  </entry>
  
  <entry>
    <title>关于栈与方法调用</title>
    <link href="https://zhcloud99.github.io/20210407071235.html"/>
    <id>https://zhcloud99.github.io/20210407071235.html</id>
    <published>2021-04-07T11:12:35.000Z</published>
    <updated>2021-04-08T06:42:17.139Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://blog.csdn.net/Casuall/article/details/99284422"><strong>参考文章</strong></a></p><hr><p>&ensp;&ensp;&ensp;&ensp;栈帧也叫过程活动记录，是编译器用来实现过程/函数调用的一种数据结构。简言之，栈帧就是利用EBP（栈帧指针，请注意不是ESP）寄存器访问局部变量、参数、函数返回地址等的手段。<br>&ensp;&ensp;&ensp;&ensp;每一次函数的调用，都会在调用栈（call stack）上维护一个独立的栈帧（stack frame）。每个独立的栈帧一般包括：</p><ul><li>函数的返回地址和参数</li><li>临时变量：包括函数的非静态局部变量以及编译器自动生成的其他临时变量</li><li>函数调用的上下文<br>&ensp;&ensp;&ensp;&ensp;栈是从高地址向低地址延伸，一个函数的栈帧用EBP和ESP这两个寄存器来划定范围。EBP指向当前栈帧的底部，ESP始终指向栈帧的顶部。<br>&ensp;&ensp;&ensp;&ensp;EBP寄存器又被称为帧指针（Frame Pointer）<br>&ensp;&ensp;&ensp;&ensp;ESP寄存器又被称为栈指针（Stack Pointer）</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;a href=&quot;https://blog.csdn.net/Casuall/article/details/99284422&quot;&gt;&lt;strong&gt;参考文章&lt;/strong&gt;&lt;/a&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;&amp;ensp;&amp;ensp;&amp;ensp;&amp;ensp;栈帧也叫过程活动记录</summary>
      
    
    
    
    <category term="随想" scheme="https://zhcloud99.github.io/categories/%E9%9A%8F%E6%83%B3/"/>
    
    
    <category term="胡思乱想" scheme="https://zhcloud99.github.io/tags/%E8%83%A1%E6%80%9D%E4%B9%B1%E6%83%B3/"/>
    
  </entry>
  
  <entry>
    <title>byte类型取值范围为什么是127到-128?</title>
    <link href="https://zhcloud99.github.io/20210406075705.html"/>
    <id>https://zhcloud99.github.io/20210406075705.html</id>
    <published>2021-04-06T11:57:05.000Z</published>
    <updated>2021-04-06T12:04:46.778Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://blog.csdn.net/heixuanfenghei/article/details/80403644?depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromBaidu-2&utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromBaidu-2"><strong>参考文章</strong></a><br>&ensp;&ensp;&ensp;&ensp;一个byte由八个位组成，如00000000，其中，前7位表示数值，第8位是符号位（0为正，1为负）。这样+1就是00000001，-1就是10000001。最大的正数就是01111111，即2^0+2^1+……+2^6=127；最小的负数，同理，为1 1111111，即-127。<br>&ensp;&ensp;&ensp;&ensp;到这里应该是许多人不明白的地方，为什么负数会到-128？<br>&ensp;&ensp;&ensp;&ensp;上述的描述会出现一个问题，就是0，会出现一个+0和一个-0。印度人他们规定-0为-128，这样就与计算机的补码（程序都是按补码运行的）完美的结合在一起。<br>&ensp;&ensp;&ensp;&ensp;以此类推，int，short，long都可以推出他们的取值范围。<br>&ensp;&ensp;&ensp;&ensp;根据微机原理，机器字长为n位的补码数，其真值的取值范围是-（2^（n-1））~+2^（n-1）+1），这里的取值范围可按照这个规定来计算。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;a href=&quot;https://blog.csdn.net/heixuanfenghei/article/details/80403644?depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogComme</summary>
      
    
    
    
    <category term="随想" scheme="https://zhcloud99.github.io/categories/%E9%9A%8F%E6%83%B3/"/>
    
    
    <category term="胡思乱想" scheme="https://zhcloud99.github.io/tags/%E8%83%A1%E6%80%9D%E4%B9%B1%E6%83%B3/"/>
    
  </entry>
  
  <entry>
    <title>存储器</title>
    <link href="https://zhcloud99.github.io/20210404025820.html"/>
    <id>https://zhcloud99.github.io/20210404025820.html</id>
    <published>2021-04-04T06:58:20.000Z</published>
    <updated>2021-04-04T07:03:02.146Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/20210404025820/clipboard.png"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img src=&quot;/20210404025820/clipboard.png&quot;&gt;&lt;/p&gt;
</summary>
      
    
    
    
    <category term="随想" scheme="https://zhcloud99.github.io/categories/%E9%9A%8F%E6%83%B3/"/>
    
    
    <category term="胡思乱想" scheme="https://zhcloud99.github.io/tags/%E8%83%A1%E6%80%9D%E4%B9%B1%E6%83%B3/"/>
    
  </entry>
  
  <entry>
    <title>C++与Java内存泄露问题</title>
    <link href="https://zhcloud99.github.io/20210401095655.html"/>
    <id>https://zhcloud99.github.io/20210401095655.html</id>
    <published>2021-04-01T01:56:55.000Z</published>
    <updated>2021-04-01T02:38:06.005Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://blog.csdn.net/u012516166/article/details/77014910"><strong>参考文章</strong></a></p><p>&ensp;&ensp;&ensp;&ensp;因为没有系统的学习过C++，闲来无事与教研室学C++同学的同学简单聊了两句，了解了下C++，又胡思乱想了一些东西。<br>&ensp;&ensp;&ensp;&ensp;C是面向过程的，C++也是封装、继承、多态、面向对象的与Java一样的。只不过C++的同学好像会花大量的时间学习指针的操作，对内存空间进行管理，防止内存泄露等问题。但是像我这种菜鸡Java，好像还没考虑过内存泄露这种事情，毕竟JVM的GC都替我做了，但是还是有必要简单了解下JVM的GC机制。</p><hr><p>&ensp;&ensp;&ensp;&ensp;Java 程序运行时使用的内存空间主要是堆、栈、方法区。</p><ul><li>方法区：主要存放静态数据、全局 static数据和常量。这块内存在程序编译时就已经分配好，并且在程序整个运行期间都存在。</li><li>栈区 ：当方法被执行时，方法体内的局部变量（其中包括基础数据类型、对象的引用）都在栈上创建，并在方法执行结束时这些局部变量所持有的内存将会自动被释放。因为栈内存分配运算内置于处理器的指令集中，效率很高，但是分配的内存容量有限。</li><li>堆区 ： 又称动态内存分配，通常就是指在程序运行时直接 new 出来的内存，也就是对象的实例。这部分内存在不使用时将会由 Java 垃圾回收器来负责回收。</li></ul><p><strong>Java内存管理</strong><br>&ensp;&ensp;&ensp;&ensp;Java的内存管理就是对象的分配和释放问题。Java程序分配了内存空间，内存释放由GC完成。在Java程序运行的过程中，为了能够正确释放对象，GC会监视每一个对象的状态（这也是为什么Java比C++慢吧），当判断这个对象不可达时，就会被GC回收掉。</p><p><strong>内存泄露</strong><br>&ensp;&ensp;&ensp;&ensp;GC回收的对象都是不可达的，但是如果这个对象是可达的，但是在程序中又不会被使用到，GC就无法回收，就会出现内存泄露。而在C++中因为没有GC机制，即使此对象是不可达的也无法被自动回收，不回收的话当然会出现内存泄露的情况。所以就内存泄露的范围来说，Java要比C++小。<br>&ensp;&ensp;&ensp;&ensp;C++程序员说Java程序员不懂内存管理，是因为大部分内存管理的工作JVM都替我们做了。但是我觉得有同样编码经验的初、中级C++与Java程序员，内存管理不一定有Java程序员做的好，毕竟JVM底层也是C++写的，初、中级的C++程序员是否能写出性能优于JVM的内存管理机制（我猜的，嘻嘻~）。<br>&ensp;&ensp;&ensp;&ensp;综上所述，Java是世界上最好的语言。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;a href=&quot;https://blog.csdn.net/u012516166/article/details/77014910&quot;&gt;&lt;strong&gt;参考文章&lt;/strong&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&amp;ensp;&amp;ensp;&amp;ensp;&amp;ensp;因为没有系统的学习过C+</summary>
      
    
    
    
    <category term="随想" scheme="https://zhcloud99.github.io/categories/%E9%9A%8F%E6%83%B3/"/>
    
    
    <category term="胡思乱想" scheme="https://zhcloud99.github.io/tags/%E8%83%A1%E6%80%9D%E4%B9%B1%E6%83%B3/"/>
    
  </entry>
  
  <entry>
    <title>关于数据类型与数据结构</title>
    <link href="https://zhcloud99.github.io/20210330054148.html"/>
    <id>https://zhcloud99.github.io/20210330054148.html</id>
    <published>2021-03-30T09:41:48.000Z</published>
    <updated>2021-03-30T09:50:32.880Z</updated>
    
    <content type="html"><![CDATA[<h2 id="关系总结"><a href="#关系总结" class="headerlink" title="关系总结:"></a><strong>关系总结:</strong></h2><p>&ensp;&ensp;&ensp;&ensp;数据类型以代码的方式实现了数据的结构（借助逻辑结构这种数学模型实现在计算机中的物理结构），并实现了对数据的操作。</p><h2 id="思路解析"><a href="#思路解析" class="headerlink" title="思路解析"></a><strong>思路解析</strong></h2><p>&ensp;&ensp;&ensp;&ensp;个人对数据类型理解：在冯诺曼的计算机体系结构中，所有的数据在计算机中都是以二进制的形式存在的，所以对计算机的存储设备来说，并没有数据类型这种东西。但是人们为了方便使用计算机处理数据并合理分配内存空间（因为不同的数据在计算机中占用不同的内存空间，为了合理使用内存空间，就必须对数据加以区分），就不断发展出了各种计算机语言。比如像汇编语言这种低级语言，在使用数据定义伪指令定义变量时，直接定义了变量在内存中占用的空间，通过数值表达式的方式区分变量。为了增加计算机语言的可读性，方便用户使用，于是出现了高级计算机语言，高级编程语言就直接定义了基本数据类型，我们不需要了解它内部是如何组成的，内存空间的管理分配也不需要我们去做，直接拿来用就可以了。而当表示复杂数据对象时，仅使用几种基本数据类型显然是不够的，便出现了抽象数据类型，用户可以使用抽象数据类型表示数据以及对数据的操作。<br>&ensp;&ensp;&ensp;&ensp;数据结构是相互之间存在一种或多种特定关系的数据元素的集合，简单的说是计算机中存储、组织数据的方式。其包括逻辑结构和物理结构。</p><ul><li>逻辑结构：逻辑结构是指数据元素之间的逻辑关系，独立于数据在计算机的存储方式，数据的逻辑结构可以看作是从具体问题抽象出来的数学模型。逻辑结构又分为线性结构（数组、链表、栈、队列）和非线性结构（树、图）。</li><li>物理结构：物理结构需要借助于计算机语言实现，决定数据是如何在计算机内存中存储的。数据的存储结构主要有：顺序存储、链式存储、索引存储和散列存储。</li></ul><p>&ensp;&ensp;个人对数据类型与数据结构之间关系的理解：数据类型以代码的方式实现了数据结构，代码编写的逻辑是借助数据结构的逻辑结构实现的，而借助这种逻辑结构实现的代码在计算机中运行后（运算处理数据），代码所处理后的数据在计算机中的存储方式也确定了，即实现了数据结构的物理结构。所以数据类型包含了数据类型（逻辑结构与物理结构）以及对数据的运算。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;关系总结&quot;&gt;&lt;a href=&quot;#关系总结&quot; class=&quot;headerlink&quot; title=&quot;关系总结:&quot;&gt;&lt;/a&gt;&lt;strong&gt;关系总结:&lt;/strong&gt;&lt;/h2&gt;&lt;p&gt;&amp;ensp;&amp;ensp;&amp;ensp;&amp;ensp;数据类型以代码的方式实现了数据的结构（</summary>
      
    
    
    
    <category term="数据结构与算法" scheme="https://zhcloud99.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="数据结构与算法" scheme="https://zhcloud99.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>数据结构概述</title>
    <link href="https://zhcloud99.github.io/20210330053023.html"/>
    <id>https://zhcloud99.github.io/20210330053023.html</id>
    <published>2021-03-30T09:30:23.000Z</published>
    <updated>2021-03-30T09:36:57.084Z</updated>
    
    <content type="html"><![CDATA[<h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><p>&ensp;&ensp;&ensp;&ensp;数据类型是一个值的集合和定义在此集合上一组操作（通常是增删改查或者操作读写的方法）的总称。其中数据类型，总的来说又分：</p><ul><li>原子类型（基本数据类型）：比如编程语言的int，double，char，byte，boolean。</li><li>复合类型（抽象数据类型）：又称结构类型，通过原子类型封装的更复杂的类型，比如面向对象语言里面的类。</li><li>抽象数据类型：抽象就是抽取出实际问题的本质。在计算机中使用二进制数来表示数据，在汇编语言中则可给出各种数据的十进制表示，它们是二进制数据的抽象，使用者在编程时可以直接使用，不必考虑实现细节。在高级语言中，则给出更高一级的数据抽象，出现了数据类型，如整型、实型、字符型等，可以进一步利用这些类型构造出线性表、栈、队列、树、图等复杂的抽象数据类型。 抽象数据类型 (Abstract Data Type, ADT) 一般指由用户定义的、表示应用问题的数学模型，以及定义在这个模型上的一组操作的总称，具体包括三部分：数据对象、数据对象上关系的集合以及对数据对象的基本操作的集合。 </li></ul><h2 id="数据"><a href="#数据" class="headerlink" title="数据"></a>数据</h2><p>&ensp;&ensp;&ensp;&ensp;数据是指未经过处理的原始记录，是关于事件之一组离散且客观的事实描述，是构成消息和知识的原始材料。一般而言，数据缺乏组织及分类，无法明确的表达事物代表的意义，它可能是一堆的杂志、一大叠的报纸、数种的开会记录或是整本病人的病历纪录。</p><h2 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h2><p>&ensp;&ensp;&ensp;&ensp;结构是指在一个系统或者材料之中，互相关联的元素的排列、组织。结构按类别可分为等级结构（有层次地排列，由上至下，一对多）、网络结构（多对多）、晶格结构（临近的个体互相连接）等。</p><h2 id="数据元素"><a href="#数据元素" class="headerlink" title="数据元素"></a>数据元素</h2><p>&ensp;&ensp;&ensp;&ensp;数据元素是最基本的数据单位，比如描述学生信息的一条记录就是一个数据元素。</p><h2 id="数据对象"><a href="#数据对象" class="headerlink" title="数据对象"></a>数据对象</h2><p>&ensp;&ensp;&ensp;&ensp;一组相同性质的数据元素的集合，比如学校中所有学生的集合。</p><h2 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h2><p>&ensp;&ensp;&ensp;&ensp;数据结构是相互之间存在一种或多种特定关系的数据元素的集合，简单的说是计算机中存储、组织数据的方式。其包括逻辑结构和物理结构。</p><h3 id="逻辑结构"><a href="#逻辑结构" class="headerlink" title="逻辑结构"></a>逻辑结构</h3><p>&ensp;&ensp;&ensp;&ensp;逻辑结构：逻辑结构是指数据元素之间的逻辑关系，独立于数据在计算机的存储方式，数据的逻辑结构可以看作是从具体问题抽象出来的数学模型。<br>&ensp;&ensp;&ensp;&ensp;逻辑结构又分为：线性结构、非线性结构。</p><ul><li>线性结构：（有且只有一个开始结点和一个终端结点，并且所有结点都最多只有一个直接前驱和一个直接后继）。线性结构典型的包括数组，链表，栈和队列。</li><li>非线性结构：（对应于线性结构，非线性结构也就是每个结点可以有不止一个直接前驱和直接后继）。非线性结构包括集合（集合结构中的数据元素之间除了“同属于一个集合”的关系外，别无其他关系。类似于数学上的集合），图，树。</li></ul><h3 id="物理结构"><a href="#物理结构" class="headerlink" title="物理结构"></a>物理结构</h3><p>&ensp;&ensp;&ensp;&ensp;物理结构：存储结构是指数据结构在计算机中的表示（又称映像），也称物理结构。它包括数据元素的表示和关系的表示。数据的存储结构是逻辑结构用计算机语言的实现，它依赖于计算机语言。数据的存储结构主要有：顺序存储、链式存储、索引存储和散列存储。注意具体的实现存储的时候，可以选择在内存里面开辟连续内存空间或者不连续的内存空间来进行存储。当然也可以混搭组成更复杂的存储方式。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;数据类型&quot;&gt;&lt;a href=&quot;#数据类型&quot; class=&quot;headerlink&quot; title=&quot;数据类型&quot;&gt;&lt;/a&gt;数据类型&lt;/h2&gt;&lt;p&gt;&amp;ensp;&amp;ensp;&amp;ensp;&amp;ensp;数据类型是一个值的集合和定义在此集合上一组操作（通常是增删改查或者操作读写的</summary>
      
    
    
    
    <category term="数据结构与算法" scheme="https://zhcloud99.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="数据结构与算法" scheme="https://zhcloud99.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
</feed>
